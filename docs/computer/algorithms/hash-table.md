# 散列表

数组是一种通过下标操作数据的线性表结构，但如果存储的位置比较稀疏，则会造成内存空间的浪费，而且数组的下标一般来说是自然数，并非支持其它情况的关键字。

散列表可以通过散列函数将关键字映射为数组的下标，然后通过下标存储和快速访问对应的数据。

## 散列函数

散列函数是将关键字计算为数组下标的函数。设计一个好的散列函数应该尽可能的满足简单均匀散列的条件，还需根据关键字的特点动态的构建散列表。

## 散列冲突

散列函数具有随机的特性，这意味着不同的关键字可能会计算出相同的散列值，这样就产生了散列冲突的情况。散列冲突的概率取决于**装载因子**（实际关键字数量/散列表长度）的大小，装载因子越大，则发生散列冲突的概率越高，反之，发生的概率越小。为了提高执行效率，可以动态批量的扩容或者缩容散列表。装载因子阈值的设置取决于对执行效率和内存空间的要求。

解决散列冲突的方法主要包括开放寻址法和链表法。

1. 开放寻址法

开放寻址法的思路是将所有的元素放到散列表中，当需要查找、插入或者删除元素时，都会根据某种**探测**规则去检查散列表中的元素。这里的探测规则包括线性探测、二次探测和双重探测。

开放寻址法的优点是数据直接存储在散列表中，查询的效率非常快，但是，如果数据量很大，则会大大增加散列冲突的概率。

2. 链表法

与开放寻址法不同的是，在链表法中的散列表存储的是链表的指针或者引用，然后每次操作元素时都是通过该指针或者引用去操作对应的链表。

当**查找**某个元素时，最坏情况下，如果所有元素都被散列到了同一链表中，则查找的时间复杂度为 O(n)。如果所有元素都被均匀的散列到散列表的任意位置，则查找的时间复杂度为 O(1)。

当**插入**和**删除**某个元素时，如果使用的是单向链表，则时间复杂度为 O(n)，如果使用的是双向链表，则完成此次操作的时间复杂度为 O(1)。

链表法非常适用于数据量大的情况下，最多也就是某个链表的长度长了点而已。而且链表法中的链表可以换成其它高级的数据结构来提高散列表在极端情况下的性能。在散列表中使用链表还可以保证数据以某种顺序存储。