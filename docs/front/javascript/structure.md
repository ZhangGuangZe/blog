# 语言结构

JavaScript 的语言结构由词法和语法结构组成。

## 词法结构

词法结构是语言的最小单元，包括空白符（White Space）、行终止符（Line Terminators）、注释（Comments）和词（Tokens）。

### 格式控制字符

Unicode 格式控制字符用于控制源文本的显示，但并不会显示出来。

- 零宽非连接符（ZERO WIDTH NON-JOINER，ZWNJ）

用于使用连词的计算机书写系统，例如阿拉伯文字或印度文字和 emoji 等。将其放入两个原本会产生连词的字符之间将不会产生连词效果。Unicode 码点为 U+200C，HTML 实体是 `&zwnj;`。

``` js
'👨\u200C💻' // => '👨‌💻' 没有产生连词效果
```

- 零宽连接符（ZERO WIDTH JOINER，ZWJ）

用于一些复杂文字的计算机排版，例如阿拉伯文字或印度文字和 emoji 等。将其放入两个本来不会连接的字符之间创建一个新的字符。
Unicode 码点为 U+200D 实体是 `&zwj;`。

``` js
'👨\u200D💻' // => '👨‍💻' 产生连词效果
```

- 字节流方向标识符（BYTE ORDER MARK，BOM）

主要用于文本开头检查文本编码和字节顺序。Unicode 码点为 U+FEFF。

扩展阅读

1. [零宽度字符：和谐？屏蔽？不存在的](https://juejin.cn/post/6844903669192720391)
2. [Be careful what you copy: Invisibly inserting usernames into text with Zero-Width Characters](https://medium.com/@umpox/be-careful-what-you-copy-invisibly-inserting-usernames-into-text-with-zero-width-characters-18b4e6f17b66)

### 空白符

空白符用于在不影响源码功能的前提下将 tokens 分隔从而提升源码的可读性。

- 制表符（CHARACTER TABULATION，TAB）

电脑上使用 TAB 键可以打印该字符，可以用于将文本排版成类似表格的结构。Unicode 码点为 U+0009，转义序列为 `\t`。

- 垂直制表符（LINE TABULATION，VT）

Unicode 码点为 U+000B，转义序列为 `\v`。

- 分页符（FORM FEED，FF)

Unicode 码点为 U+000C，转义序列为 `\f`。

- 空格（SPACE，SP）

平常使用的空格。Unicode 码点为 U+0020。

- 无间断空格（NO-BREAK SPACE，NBSP）

可以使该空格处的两个字符产生不换行的效果。码点为 U+00A0，HTML 实体为 `&nbsp;`。例如：

<div>我们可以控制浏览器窗口大小查看后面两个 “Java Script” 文本的效果，这是一段中间没有添加无间断空格 Java Script 文本，这是一段中间添加了无间断空格 Java&nbsp;Script 的文本。</div>

可以看到，没有添加无间断空格的 “Java Script” 文本的 “Java” 和 “Script” 两个字符之间出现了换行效果，而添加了无间断空格的文本两字符之间没有出现换行效果。

- 其他空白符

### 行终止符

行终止符用于表示一行文本的结束和新文本的开始，同样可以将 tokens 分隔从而提高源码的可读性，不过行终止符会影响源码的执行，还有自动插入分号规则的执行。

- 换行符（LINE FEED，LF）

Unicode 码点为 U+000A，转义序列是 `\n`。

- 回车符（CARRIAGE RETURN，CR）

Unicode 码点为 U+000D，转义序列为 `\r`。

- 行分隔符（LINE SEPARATOR，LS）

Unicode 码点为 U+2028。

- 段分隔符（PARAGRAPH SEPARATOR，PS）

Unicode 码点为 U+2029。

::: tip
Windows 操作系统继承了电传打字机使用 CR + LF 作为换行符的传统，而类 Unix 操作系统遵循了 Multics 操作系统单独使用 LF 作为换行符的规定。更多换行符的内容，请点击[这里](https://en.wikipedia.org/wiki/Newline)。
:::

### 注释

注释可以为源码提供提示信息，增强源码的可读性，还可以屏蔽指定源码，阻止其执行。

注释包括**单行注释**和**多行注释**两种。

``` js
// 单行注释
/* 一行内的多行注释 */
/*
 * 多行注释（注释内容的 * 字符不是必须的）
 */
```

其中单行注释以 `//` 开头，除了行终结符以外的其它源字符都可以作为单行注释的一部分。多行注释以 `/*` 开头，以 `*/` 结尾，多行注释内容不能嵌套，多行注释可以包含任意源字符，但是 `*` 和 `/` 不能组合存在于多行注释中，因为 `*/` 会被视为多行注释的结束标记。

### 词

#### 标识符

在计算机科学中，**标识符**（Identifier）是命名实体（name entities）的词法标记。而在计算机语言中，标识符则是命名语言实体的词法标记。JavaScript 的语言实体包括变量、属性、函数、类和模块等，而标识符用于命名这些实体。

JavaScript 标识符由第一个字符（Start）和后续字符（Part）两部分构成：

- 第一个字符必须是字母、下划线（_）或者美元符号（$）；

- 后续字符可以是字母、下划线、美元符号或数字。

一般情况下，第一个字符以下划线开头的标识符表示私有属性或全局私有变量；而第一个字符以美元符号开头的标识符常用在框架的 API 命名，这样可以避免框架 API 与用户标识符冲突；而不能以数字作为第一个字符为了避免标识符与整数字面量混淆。

::: warning
实际上，JavaSCript 可以使用 Unicode 字符作为标识符，并且后续字符可以包含零宽非连接符和零宽连接符，但不建议使用。
:::

#### 保留字

在计算机科学中，**保留字**（Reserved word）是不能用作标识符的单词，而**关键字**（Keyword）是特定上下文具有特殊含义的单词，可以在特定上下文用作标识符，关键字是保留字的子集。

JavaScript 的保留字包括：

``` js
await break case catch class const continue debugger default delete do else enum export extends false finally for function if implements import in instanceof interface new null package private protected public return super switch this throw true try typeof var void while with yield
```

`yield` 虽然是保留字，但可以作为标识符使用。

`enum` 是未来保留字。`implements` `interface` `package` `private` `protected` `public` 在严格模式下作为未来保留字，用于语言未来扩展新特性。

`let` `static` 在严格模式下是保留字。

`arguments` `eval` 虽然即不是保留字也不是关键字，但在严格模式不允许作为标识符使用。

`undefined` 虽然既不是保留字也不是关键字，但可以在严格模式中作为变量名使用。

保留字的定义会引发一些问题。JavaScript 由于历史原因，保留字规则非常复杂，对于新手来说，不利于记忆，唯一记忆的办法就是**不要使用以上单词作为标识符**；对于语言发展来说，不利于语言新特性的扩展。

`as` `async` `from` `get` `of` `set` `target` 是关键字，但不是保留字，可以作为标识符使用。

#### 符号

```
{ ( ) [ ] . ... ; , < > <= >= == != === !== + - * % ** ++ -- << >> >>> & | ^ ! ~ && || ?? ?. ? : = += -= *= %= **= <<= >>= >>>= &= |= ^= &&= ||= ??= => / /= }
```

其中，值得注意的是 `?.` `/` `/=` `}` 符号。

#### 字面量

**字面量**（Literal）是一种在程序中可以直接使用数据值的符号，也称直接量。

##### 空值字面量

``` js
null
undefined
```

##### 布尔值字面量

``` js
true
false
```

##### 数值字面量

- 十进制数字面量

整数

``` js
0
24
```

浮点数

``` js
.1   // => 0.1 (不推荐省略前导零)
0.1
3.1415926
```

以下浮点数将会自动转换为整数：

``` js
1.   // => 1 (不推荐省略后置零)
1.0  // => 1
1.00 // => 1
```

科学计数法

科学记数法使用 `E` 或 `e` 后跟可选的 + 或 - 操作符后再跟上整数表示非常大或非常小的数（整数或浮点数），`E` 或 `e` 后面的整数表示实数值乘以 10 多少次幂。

``` js
1e32
1e-32
3.1415E32
3.1415E-32
```

ES6 增加了二进制和八进制表示法。

- 二进制数字面量

使用 `0b` 或 `0B` 表示二进制数，二进制的数值只包含 0 和 1。

``` js
0b00011000 // => 24
0B00011000 // => 24
```

- 八进制数字面量

使用 `0o` 或 `0O` 表示八进制数，八进制的数值包括 0 至 7 范围内的整数。

``` js
0o030 // => 24
0O030 // => 24
```

为了方便区分 0 和 大 O，推荐使用 小 o 表示八进制数。

::: warning
在 ES6 以前，可以使用一个前导 0 后面加 0 至 7 组合的整数表示八进制数，而使用上述超出范围的整数表示十进制数，例如 `030` 返回的数值是八进制的 24 而不是十进制的 30。但在严格模式中，不允许使用前导零来表示二进制和十进制数，使用前导零会被视为语法错误。
:::

- 十六进制数字面量

使用 `0x` 或 `0X` 表示十六进制数，十六进制的数值包括 0 至 9 以及 A（或 a）至 F（f），A 至 F 表示 10 至 15。

``` js
0x18 // => 24
0x1F // => 31
0x1f // => 31
```

- 大整数字面量

可以使用以上进制数加后缀 n 表示大整数，但不能使用浮点数和科学计数法表示大整数，因为这样会导致语法错误。

``` js
1234567890n // => 1234567890n
0b11110000n // => 240n
0o77777777n // => 16777215n
0xA0B1C2D3n // => 2696004307n
1.24n       // => SyntaxError
1e24n       // => SyntaxError
```

- 数值分隔符

ECMA2021 新增了数值分隔符，在**数值之间**只能使用一个连续的下划线（`_`）分隔数值可以提高数值字面量的可读性。数值分隔符可以用在以上所有数值字面量数值部分中间，甚至可以用在浮点数小数部分和科学记数法指数部分数值中间，但是数值前后和数值符号前后不能出现数值分隔符，否则会导致语法错误。

``` js
// good code
1_234_567_890   // => 1234567890
0b1111_0000     // => 240
0o77_777_777    // => 16777215
0xA0_B1_C2_D3   // => 2696004307
3.1_415_926     // => 3.1415926
0.12e1_00       // => 1.2e+99
1_000_000_000n  // => 1000000000n

// bad code
_1234567890
1234567890_
0_b11110000
0b_11110000
3_.1415926
3._1415926
0.12e_100
1000000000_n
1__000
```

##### 字符串字面量

我们可以使用双引号（""）和单引号（''）包括零个、一个或多个 Unicode 字符表示字符串字面量，而且当前引号可以嵌套其他引号。

``` js
""
"foo"
'1.24'
"I'm front-boy."
'name="front-boy"'
```

- 转义序列

转义序列使用反斜杠（\）与后面的字符组合，表示在字符串中无法直接使用或输入和拥有其他含义的字符。JavaScript 的转义序列包括字符转义序列、十六进制转义序列和 Unicode 转义序列。

字符转义序列

使用反斜杠后面加上需要转义的字符表示字符转义序列。例如转义换行符、单引号和双引号等字符。

``` js
console.log("This is the first line.\nThis is the second line.");
console.log('I\'m front-boy.');
console.log("She said \"hi\", He said.");
```

十六进制转义序列

使用 `\x` 开头后面加上两位十六进制数表示 0 至 FF 码点内的字符。

``` js
'\xFF' // => ÿ
```

Unicode 转义序列

使用 `\u` 开头后面加上四位十六进制数表示 0 至 FFFF 码点内的字符。

``` js
'\u2EC1' // => 虎
```

ES6 增加代理对表示 FFFF 至 10FFFF 码点内的字符。

``` js
// ES5
'\ud83d\ude32' // => 😲
// ES6
'\u{1F632}' // => 😲

'\ud83d\ude32' === '\u{1F632}' // => true
```

以下是所有转义序列：

| 转义序列  | Unicode             | 说明              |
| -------- |:------------------: | ----------------- |
| \0       | \u0000              | NUL 字符           |
| \b       | \u0008              | 退格符             |
| \t       | \u0009              | 制表符             |
| \n       | \u000A              | 换行符             |
| \v       | \u000B              | 垂直制表符         |
| \f       | \u000C              | 分页符             |
| \r       | \u000D              | 回车符             |
| \\"      | \u0022              | 双引号             |
| \\'      | \u0027              | 单引号             |
| \\\      | \u005C              | 反斜杠             |
| \xnn     | \u0000 至 \u00FF    | 2 位十六进制       |
| \unnnn   | \u0000 至 \uFFFF    | 4 位十六进制       |
| \u{n}    | \uFFFF 至 \u10FFFF  | 1 至 6 位十六进制  |

最后还有一种鲜为人知的八进制转义序列，例如 `'\312'`。

- 模板字面量

为了增强字符串的能力，同时提供对模板的支持并降低注入等安全风险，ES6 新增了模板字面量，使用反引号（``）标识，需要使用转义才能在模板字面量中使用反引号。

多行字符串

在 ES6 之前，JavaScript 的字符串一定要在一行才行。如果想要软换行字符串，也就是看起来是多行其实是一行的字符串，那需要在每行字符串末尾增加一个反斜杠。

``` js
'This is actually \
a line.' // => This is actually a line.
```

如果想要硬换行，也就是真正意义上的将一行字符串转换为多行字符串，那就需要在换行字符串前使用转义的换行符。

``` js
console.log("This is the first line.\nThis is the second line.");
```

而在 ES6 的模板字面量中默认支持多行字符串，模板字面量会保留换行符空白符等符号。

``` js
console.log(`This is the first line.
This is the second line.`);
```

字符串插值

在 ES6 之前，如果需要给字符串插值，我们需要使用字符串拼接的形式才能做到。

``` js
1 + ' + ' + 2 + ' = ' + (1 + 2) // => 1 + 2 = 3
```

现在我们可以在 `${` 和 `}` 占位符之间插入任意的 JavaScript 表达式。表达式会将值立即求出，然后转换为字符串，最终替换占位符并与其他字符串拼接形成新的字符串。

``` js
console.log(`${1} + ${2} = ${1 + 2}`); // => 1 + 2 = 3
```

模板字符串支持嵌套插值。

``` js
console.log(`${`${1} + ${2}`} = ${1 + 2}`); // => 1 + 2 = 3
```

标签函数

无论是使用普通字符串还是模板字符串进行插值都存在注入等安全风险，不过我们可以使用模板函数对模板字符串的值进行预处理来尽可能的规避风险，也就是对某些字符进行转义、过滤等自定义操作并返回处理好的字符串。

模板字符串前面的标识符作为函数名，`${}` 占位符将字符串拆分为多段并组合到数组中作为函数的第一个参数，占位符内的值作为函数的剩余参数，标签函数的第一个参数包括一个 `raw` 属性，我们通过它可以获取未经处理的原始字符串。

``` js
function tag(strings, ...values) {
  console.log(strings, ...values); // => ['a', 'b', 'c', ''] 1 2 3
  console.log(strings.raw[0]); // => a\n
}
tag`a\n${1}b${2}c${3}`
```

为了能够在标签函数中正常嵌套其他模板语言，ES2018 在标签函数中放宽了对非法转义序列的语法限制，非法转义序列在标签函数中将返回 `undefined` 而不再是抛出语法错误，不过在其他字符串中并未解除该限制。

``` js
function latex(str) {
  console.log(str[0], str.raw[0]); // => undefined '\\unicode'
}
latex`\unicode`

`\unicode` // => SyntaxError: Invalid Unicode escape sequence
```

##### 正则表达式字面量

正则表达式字面量由一对斜杠（/）包括的**模式**（pattern）和可选的**标志**（flags）两个部分构成。例如：

``` js
/pattern/flags
```

**模式**

模式是由普通字符和**元字符**（拥有特殊含义的字符）构成的字符串，用于匹配和处理简单或复杂的文本。正则表达式的元字符包括：

``` js
. [] + * ? {} ^ $ () / | \ <> ! =
```

如果需要在模式中使用以上元字符或者具有特殊含义的字符序列，需要使用反斜杠（\）转义。

::: tip
因为 \b 在正则表达式中有其他含义，所以退格符需要使用 [\b] 匹配。在正则表达式中，可以使用 \c 开头的前缀指定[控制字符](https://zh.wikipedia.org/wiki/%E6%8E%A7%E5%88%B6%E5%AD%97%E7%AC%A6)。例如：`\cH` 可以匹配退格符。不过这种方式很少见。
:::

下面将介绍各元字符的含义及使用场景。

- 单个匹配

单个匹配可以匹配单个字符或者字符集合中任意一个字符。

1. 匹配任意字符

`.` 字符用于匹配的任意单个字符（行终止符除外）。

2. 匹配特定字符

`[...]` 字符用于定义一个字符集合，表示匹配该特定字符集合中的任意一个字符。例如，只匹配数字字符等其它特定或者自定义字符集合，那么可以使用 `/[0123456789]/` 这种枚举的模式匹配，不过这样表示略显冗余。

`-` 字符用于定义一个字符区间，常见的字符区间包括数字字符和字母字符区间，这样，我们就可以使用区间模式匹配特定字符集合。例如：

``` js
[1-9] // 匹配数字
[a-z] // 匹配小写字母
[A-Z] // 匹配大写字母
```

如果需要在字符集合中包含连字符，只需在字符集合末尾添加该字符即可。例如 `/[A-Za-z0-9-]/` 模式可以用于匹配带有字母、数字和连字符。

`^` 字符用于定义需要排除的字符集合。例如 `/[^0-9]/` 模式可以排除数字字符，匹配非数字字符。

正则表达式还提供了字符类来更为简单的匹配特定类型的字符。

| 字符类    | 匹配字符                       | 字符集合                                                                          |
| -------- | ----------------------------- | -------------------------------------------------------------------------------- |
| \d       | 任意一个数字字符               | [0-9]                                                                            |
| \D       | 任意一个非数字字符             | [^0-9]                                                                           |
| \w       | 任意一个字母数字或下划线字符    | [A-Za-z0-9-]                                                                     |
| \W       | 任意一个非字母数字或下划线字符  | [^A-Za-z0-9-]                                                                    |
| \s       | 任意 Unicode 空白字符          | [\f\n\r\t\v\u00a0\u1680\u180e\u2000\u200a-\u2028\u2029\u202f\u205f\u3000\ufeff]  |
| \S       | 任意非 Unicode 空白字符        | [^\f\n\r\t\v\u00a0\u1680\u180e\u2000\u200a-\u2028\u2029\u202f\u205f\u3000\ufeff] |

为了匹配更多类型的 Unicode 字符，ES2018 新增了 Unicode 字符类，使用 `\p{...}` 和 `\P{...}` 匹配和排除某种 Unicode 字符类型。可以使用以下方式表示 Unicode 字符类：

``` js
\p{Unicode 属性名}
\p{Unicode 属性值}
\p{Unicode 属性名 = Unicode 属性值}
```

例如：

``` js
/\p{Number}/ // 匹配所有类型的数字
/\p{White_Space}/ // 匹配所有 Unicode 空白符
/\p{Script=Greek}/ // 匹配希腊文
/[\p{Alphabetic}\p{Decimal_Number}\p{Mark}\p{Connector_Punctuation}\p{Join_Control}]/ // 匹配所有文字字符
```

更多 Unicode 字符类请点击[这里](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Guide/Regular_Expressions/Unicode_Property_Escapes)。

- 重复匹配

重复匹配可以匹配多个连续重复的字符或字符集合。

1. 贪婪匹配

| 字符    | 说明                                                       |
| ------- | ---------------------------------------------------------- |
| +       | 字符或字符集合重复**一次或多次**                             |
| *       | 字符或字符集合重复**零次或多次**                             |
| ?       | 字符或字符集合重复**零次或一次**，相当于该字符是**可选**的    |
| {n}     | 字符或字符集合重复 n 次                                     |
| {m,n}   | 字符或字符集合重复至少 m 次，至多 n 次                       |
| {n,}    | 字符或字符集合重复至少 n 次                                 |

2. 惰性匹配

贪婪匹配会尽可能多的匹配文本，如果想要尽可能少的匹配则需要在以上字符后面添加 `?`，表示惰性匹配文本。例如，`/a+?/` 模式表示最多只匹配文本的第一个 a 字符。

- 位置匹配

位置匹配可以对文本特定位置进行匹配。

| 字符    | 说明                                                       |
| ------- | ---------------------------------------------------------- |
| ^       | 匹配字符串开始位置                                          |
| $       | 匹配字符串结束位置                                          |
| \b      | 匹配单词边界                                                |
| \B      | 匹配非单词边界                                              |

- 子表达式

`(...)` 元字符用于表示子表达式。在子表达式中，子表达式可以用于任选、分组和反向引用以及断言。子表达式支持嵌套。

1. 任选

在子表达式中使用管道符（`|`）可以将子表达式分为多个选项，并从左到右依次使用这些选项匹配文本，如果匹配到将不会使用剩余的选项匹配。例如，`/(abc|xyz){3}/` 模式将匹配 abc 或 xyz 重复 3 次的文本。

2. 分组和反向引用

子表达式可以将正则表达式分为多个组，分组将会在匹配文本的同时提供一个捕获分组的引用。如果需要反向引用模式中的分组，可以在模式中使用反斜杠后面紧跟正整数的方式引用分组内容。例如，下面的模式将会引用分组的引号，从而匹配相同的引号：

``` js
/(["'`])[^"'`]*\1/
```

如果我们并不需要捕获分组内容，可以使用在子表达式开头添加 `?:` 元字符，表示非捕获组。例如，在 `/(?:a)\1/` 模式中，反向引用将捕获不到分组中的内容。

为了更直观引用分组而不是使用数字引用，ES2018 新增了具名捕获组特性，在子表达式开头添加 `?<...>` 元字符表示具名捕获组，可以通过 `\k<...>` 元字符反向引用具名捕获组。例如，通过具名捕获组改造引号匹配模式：

``` js
/(?<quote>["'`])[^"'`]*\k<quote>/
```

4. 断言

断言用于控制匹配结果返回的文本位置。

向前断言使用 `x(?=y)` 表示。匹配 x 后面包含 y 文本并返回 x 的匹配结果。例如，`/[A-Z][a-zA-Z]+(?=Script)/` 模式对于 LiveScript 文本，将匹配包含 Script 的文本并返回 Script 文本前的 Live 文本。

向前否定断言使用 `x(?!y)` 表示。匹配 x 后面不包含 y 的文本并返回 x 的匹配结果。例如，`/Java(?!Script)/` 模式匹配 JavaBeans 文本并返回 Java 文本，但并不匹配包含 Script 的 JavaScript 文本。

ES2018 增加了向后断言特性。

向后断言使用 `(?<=y)x` 表示。匹配 x 前面包含 y 文本并返回 x 的匹配结果。例如，`/(?<=\$)\d+/` 模式匹配包含美元符号的 $123 文本并返回美元符号后面的 123 数值。

向后否定断言使用 `(?<!y)x` 表示。匹配 x 前面不包含 y 文本并返回 x 的匹配结果。例如，`/\b(?<!\$)\d+\b/` 模式匹配文本中不包含美元符号的数值。注意，使用 `\b` 单词边界可以避免匹配到拥有美元符号后面的数值字符。

**标志**

标志用于控制文本的搜索模式，标志由一个或多个以下字母表示。

| 标志    | 说明                                                            |
| ------- | -------------------------------------------------------------- |
| g       | 全局搜索模式                                                    |
| i       | 不区分大小写搜索模式                                             |
| m       | 多行搜索模式，适用于多行字符串，^ 和 $ 元字符将匹配每行的开头和结尾  |
| u       | Unicode 搜索模式（ES6），用于精确的匹配码点及 Unicode 字符类       |
| y       | 定点搜索模式（ES6)                                              |
| s       | 任意字符搜索模式（ES2018），模式中使用 `.` 元字符相当于 [^]        |

## 语法结构

### 表达式

### 语句

### 结构体

### 模块和脚本