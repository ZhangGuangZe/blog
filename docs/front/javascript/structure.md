# 语言结构

JavaScript 的语言结构由词法和语法结构组成。

## 词法结构

词法结构是语言的最小单元，包括空白符（White Space）、行终止符（Line Terminators）、注释（Comments）和词（Tokens）。

### 格式控制字符

Unicode 格式控制字符用于控制源文本的显示，但并不会显示出来。

- 零宽非连接符（ZERO WIDTH NON-JOINER，ZWNJ）

用于使用连词的计算机书写系统，例如阿拉伯文字或印度文字和 emoji 等。将其放入两个原本会产生连词的字符之间将不会产生连词效果。Unicode 码点为 U+200C，HTML 实体是 `&zwnj;`。

``` js
'👨\u200C💻' // => '👨‌💻' 没有产生连词效果
```

- 零宽连接符（ZERO WIDTH JOINER，ZWJ）

用于一些复杂文字的计算机排版，例如阿拉伯文字或印度文字和 emoji 等。将其放入两个本来不会连接的字符之间创建一个新的字符。
Unicode 码点为 U+200D 实体是 `&zwj;`。

``` js
'👨\u200D💻' // => '👨‍💻' 产生连词效果
```

- 字节流方向标识符（BYTE ORDER MARK，BOM）

主要用于文本开头检查文本编码和字节顺序。Unicode 码点为 U+FEFF。

扩展阅读

1. [零宽度字符：和谐？屏蔽？不存在的](https://juejin.cn/post/6844903669192720391)
2. [Be careful what you copy: Invisibly inserting usernames into text with Zero-Width Characters](https://medium.com/@umpox/be-careful-what-you-copy-invisibly-inserting-usernames-into-text-with-zero-width-characters-18b4e6f17b66)

### 空白符

空白符用于在不影响源码功能的前提下将 tokens 分隔从而提升源码的可读性。

- 制表符（CHARACTER TABULATION，TAB）

电脑上使用 TAB 键可以打印该字符，可以用于将文本排版成类似表格的结构。Unicode 码点为 U+0009，转义序列为 `\t`。

- 垂直制表符（LINE TABULATION，VT）

Unicode 码点为 U+000B，转义序列为 `\v`。

- 分页符（FORM FEED，FF)

Unicode 码点为 U+000C，转义序列为 `\f`。

- 空格（SPACE，SP）

平常使用的空格。Unicode 码点为 U+0020。

- 无间断空格（NO-BREAK SPACE，NBSP）

可以使该空格处的两个字符产生不换行的效果。码点为 U+00A0，HTML 实体为 `&nbsp;`。例如：

<div>我们可以控制浏览器窗口大小查看后面两个 “Java Script” 文本的效果，这是一段中间没有添加无间断空格 Java Script 文本，这是一段中间添加了无间断空格 Java&nbsp;Script 的文本。</div>

可以看到，没有添加无间断空格的 “Java Script” 文本的 “Java” 和 “Script” 两个字符之间出现了换行效果，而添加了无间断空格的文本两字符之间没有出现换行效果。

- 其他空白符

### 行终止符

行终止符用于表示一行文本的结束和新文本的开始，同样可以将 tokens 分隔从而提高源码的可读性，不过行终止符会影响源码的执行，还有自动插入分号规则的执行。

- 换行符（LINE FEED，LF）

Unicode 码点为 U+000A，转义序列是 `\n`。

- 回车符（CARRIAGE RETURN，CR）

Unicode 码点为 U+000D，转义序列为 `\r`。

- 行分隔符（LINE SEPARATOR，LS）

Unicode 码点为 U+2028。

- 段分隔符（PARAGRAPH SEPARATOR，PS）

Unicode 码点为 U+2029。

::: tip
Windows 操作系统继承了电传打字机使用 CR + LF 作为换行符的传统，而类 Unix 操作系统遵循了 Multics 操作系统单独使用 LF 作为换行符的规定。更多换行符的内容，请点击[这里](https://en.wikipedia.org/wiki/Newline)。
:::

### 注释

注释可以为源码提供提示信息，增强源码的可读性，还可以屏蔽指定源码，阻止其执行。

注释包括**单行注释**和**多行注释**两种。

``` js
// 单行注释
/* 一行内的多行注释 */
/*
 * 多行注释（注释内容的 * 字符不是必须的）
 */
```

其中单行注释以 `//` 开头，除了行终结符以外的其它源字符都可以作为单行注释的一部分。多行注释以 `/*` 开头，以 `*/` 结尾，多行注释内容不能嵌套，多行注释可以包含任意源字符，但是 `*` 和 `/` 不能组合存在于多行注释中，因为 `*/` 会被视为多行注释的结束标记。

### 词

#### 标识符

在计算机科学中，**标识符**（Identifier）是命名实体（name entities）的词法标记。而在计算机语言中，标识符则是命名语言实体的词法标记。JavaScript 的语言实体包括变量、属性、函数、类和模块等，而标识符用于命名这些实体。

JavaScript 标识符由第一个字符（Start）和后续字符（Part）两部分构成：

- 第一个字符必须是字母、下划线（_）或者美元符号（$）；

- 后续字符可以是字母、下划线、美元符号或数字。

一般情况下，第一个字符以下划线开头的标识符表示私有属性或全局私有变量；而第一个字符以美元符号开头的标识符常用在框架的 API 命名，这样可以避免框架 API 与用户标识符冲突；而不能以数字作为第一个字符为了避免标识符与整数字面量混淆。

::: warning
实际上，JavaSCript 可以使用 Unicode 字符作为标识符，并且后续字符可以包含零宽非连接符和零宽连接符，但不建议使用。
:::

#### 保留字

在计算机科学中，**保留字**（Reserved word）是不能用作标识符的单词，而**关键字**（Keyword）是特定上下文具有特殊含义的单词，可以在特定上下文用作标识符，关键字是保留字的子集。

JavaScript 的保留字包括：

``` js
await break case catch class const continue debugger default delete do else enum export extends false finally for function if implements import in instanceof interface new null package private protected public return super switch this throw true try typeof var void while with yield
```

`yield` 虽然是保留字，但可以作为标识符使用。

`enum` 是未来保留字。`implements` `interface` `package` `private` `protected` `public` 在严格模式下作为未来保留字，用于语言未来扩展新特性。

`let` `static` 在严格模式下是保留字。

`arguments` `eval` 虽然即不是保留字也不是关键字，但在严格模式不允许作为标识符使用。

`undefined` 虽然既不是保留字也不是关键字，但可以在严格模式中作为变量名使用。

保留字的定义会引发一些问题。JavaScript 由于历史原因，保留字规则非常复杂，对于新手来说，不利于记忆，唯一记忆的办法就是**不要使用以上单词作为标识符**；对于语言发展来说，不利于语言新特性的扩展。

`as` `async` `from` `get` `of` `set` `target` 是关键字，但不是保留字，可以作为标识符使用。


#### 符号

```
{ ( ) [ ] . ... ; , < > <= >= == != === !== + - * % ** ++ -- << >> >>> & | ^ ! ~ && || ?? ?. ? : = += -= *= %= **= <<= >>= >>>= &= |= ^= &&= ||= ??= => / /= }
```

其中，值得注意的是 `?.` `/` `/=` `}` 符号。

#### 字面量

**字面量**（Literal）是一种在程序中可以直接使用数据值的符号，也称直接量。

##### 空值字面量

``` js
null
undefined
```

##### 布尔值字面量

``` js
true
false
```

##### 数值字面量

- 十进制数字面量

整数

``` js
0
24
```

浮点数

``` js
.1   // => 0.1 (不推荐省略前导零)
0.1
3.1415926
```

以下浮点数将会自动转换为整数：

``` js
1.   // => 1 (不推荐省略后置零)
1.0  // => 1
1.00 // => 1
```

科学计数法

科学记数法使用 `E` 或 `e` 后跟可选的 + 或 - 操作符后再跟上整数表示非常大或非常小的数（整数或浮点数），`E` 或 `e` 后面的整数表示实数值乘以 10 多少次幂。

``` js
1e32
1e-32
3.1415E32
3.1415E-32
```

ES6 增加了二进制和八进制表示法。

- 二进制数字面量

使用 `0b` 或 `0B` 表示二进制数，二进制的数值只包含 0 和 1。

``` js
0b00011000 // => 24
0B00011000 // => 24
```

- 八进制数字面量

使用 `0o` 或 `0O` 表示八进制数，八进制的数值包括 0 至 7 范围内的整数。

``` js
0o030 // => 24
0O030 // => 24
```

为了方便区分 0 和 大 O，推荐使用 小 o 表示八进制数。

::: warning
在 ES6 以前，可以使用一个前导 0 后面加 0 至 7 组合的整数表示八进制数，而使用上述超出范围的整数表示十进制数，例如 `030` 返回的数值是八进制的 24 而不是十进制的 30。但在严格模式中，不允许使用前导零来表示二进制和十进制数，使用前导零会被视为语法错误。
:::

- 十六进制数字面量

使用 `0x` 或 `0X` 表示十六进制数，十六进制的数值包括 0 至 9 以及 A（或 a）至 F（f），A 至 F 表示 10 至 15。

``` js
0x18 // => 24
0x1F // => 31
0x1f // => 31
```

- 大整数字面量

可以使用以上进制数加后缀 n 表示大整数，但不能使用浮点数和科学计数法表示大整数，因为这样会导致语法错误。

``` js
1234567890n // => 1234567890n
0b11110000n // => 240n
0o77777777n // => 16777215n
0xA0B1C2D3n // => 2696004307n
1.24n       // => SyntaxError
1e24n       // => SyntaxError
```

- 数值分隔符

ECMA2021 新增了数值分隔符，在**数值之间**只能使用一个连续的下划线（`_`）分隔数值可以提高数值字面量的可读性。数值分隔符可以用在以上所有数值字面量数值部分中间，甚至可以用在浮点数小数部分和科学记数法指数部分数值中间，但是数值前后和数值符号前后不能出现数值分隔符，否则会导致语法错误。

``` js
// good code
1_234_567_890   // => 1234567890
0b1111_0000     // => 240
0o77_777_777    // => 16777215
0xA0_B1_C2_D3   // => 2696004307
3.1_415_926     // => 3.1415926
0.12e1_00       // => 1.2e+99
1_000_000_000n  // => 1000000000n

// bad code
_1234567890
1234567890_
0_b11110000
0b_11110000
3_.1415926
3._1415926
0.12e_100
1000000000_n
1__000
```

##### 字符串字面量

我们可以使用双引号（""）和单引号（''）包括零个、一个或多个 Unicode 字符表示字符串字面量，而且当前引号可以嵌套其他引号。

``` js
""
"foo"
'1.24'
"I'm front-boy."
'name="front-boy"'
```

- 转义序列

转义序列使用反斜杠（\）与后面的字符组合，表示在字符串中无法直接使用或输入和拥有其他含义的字符。JavaScript 的转义序列包括字符转义序列、十六进制转义序列和 Unicode 转义序列。

字符转义序列

使用反斜杠后面加上需要转义的字符表示字符转义序列。例如转义换行符、单引号和双引号等字符。

``` js
console.log("This is the first line.\nThis is the second line.");
console.log('I\'m front-boy.');
console.log("She said \"hi\", He said.");
```

十六进制转义序列

使用 `\x` 开头后面加上两位十六进制数表示 0 至 FF 码点内的字符。

``` js
'\xFF' // => ÿ
```

Unicode 转义序列

使用 `\u` 开头后面加上四位十六进制数表示 0 至 FFFF 码点内的字符。

``` js
'\u2EC1' // => 虎
```

ES6 增加代理对表示 FFFF 至 10FFFF 码点内的字符。

``` js
// ES5
'\ud83d\ude32' // => 😲
// ES6
'\u{1F632}' // => 😲

'\ud83d\ude32' === '\u{1F632}' // => true
```

以下是所有转义序列：

| 转义序列  | Unicode             | 说明              |
| -------- |:------------------: | ----------------- |
| \0       | \u0000              | NUL 字符           |
| \b       | \u0008              | 退格符             |
| \t       | \u0009              | 制表符             |
| \n       | \u000A              | 换行符             |
| \v       | \u000B              | 垂直制表符         |
| \f       | \u000C              | 分页符             |
| \r       | \u000D              | 回车符             |
| \\"      | \u0022              | 双引号             |
| \\'      | \u0027              | 单引号             |
| \\\      | \u005C              | 反斜杠             |
| \xnn     | \u0000 至 \u00FF    | 2 位十六进制       |
| \unnnn   | \u0000 至 \uFFFF    | 4 位十六进制       |
| \u{n}    | \uFFFF 至 \u10FFFF  | 1 至 6 位十六进制  |

最后还有一种鲜为人知的八进制转义序列，例如 `'\312'`。

- 模板字面量

为了增强字符串的能力，同时提供对模板的支持并降低注入等安全风险，ES6 新增了模板字面量，使用反引号（``）标识，需要使用转义才能在模板字面量中使用反引号。

多行字符串

在 ES6 之前，JavaScript 的字符串一定要在一行才行。如果想要软换行字符串，也就是看起来是多行其实是一行的字符串，那需要在每行字符串末尾增加一个反斜杠。

``` js
'This is actually \
a line.' // => This is actually a line.
```

如果想要硬换行，也就是真正意义上的将一行字符串转换为多行字符串，那就需要在换行字符串前使用转义的换行符。

``` js
console.log("This is the first line.\nThis is the second line.");
```

而在 ES6 的模板字面量中默认支持多行字符串，模板字面量会保留换行符空白符等符号。

``` js
console.log(`This is the first line.
This is the second line.`);
```

字符串插值

在 ES6 之前，如果需要给字符串插值，我们需要使用字符串拼接的形式才能做到。

``` js
1 + ' + ' + 2 + ' = ' + (1 + 2) // => 1 + 2 = 3
```

现在我们可以在 `${` 和 `}` 占位符之间插入任意的 JavaScript 表达式。表达式会将值立即求出，然后转换为字符串，最终替换占位符并与其他字符串拼接形成新的字符串。

``` js
console.log(`${1} + ${2} = ${1 + 2}`); // => 1 + 2 = 3
```

模板字符串支持嵌套插值。

``` js
console.log(`${`${1} + ${2}`} = ${1 + 2}`); // => 1 + 2 = 3
```

标签函数

无论是使用普通字符串还是模板字符串进行插值都存在注入等安全风险，不过我们可以使用模板函数对模板字符串的值进行预处理来尽可能的规避风险，也就是对某些字符进行转义、过滤等自定义操作并返回处理好的字符串。

模板字符串前面的标识符作为函数名，`${}` 占位符将字符串拆分为多段并组合到数组中作为函数的第一个参数，占位符内的值作为函数的剩余参数，标签函数的第一个参数包括一个 `raw` 属性，我们通过它可以获取未经处理的原始字符串。

``` js
function tag(strings, ...values) {
  console.log(strings, ...values); // => ['a', 'b', 'c', ''] 1 2 3
  console.log(strings.raw[0]); // => a\n
}
tag`a\n${1}b${2}c${3}`
```

为了能够在标签函数中正常嵌套其他模板语言，ES2018 在标签函数中放宽了对非法转义序列的语法限制，非法转义序列在标签函数中将返回 `undefined` 而不再是抛出语法错误，不过在其他字符串中并未解除该限制。

``` js
function latex(str) {
  console.log(str[0], str.raw[0]); // => undefined '\\unicode'
}
latex`\unicode`

`\unicode` // => SyntaxError: Invalid Unicode escape sequence
```

##### 正则表达式字面量

## 语法结构

### 表达式

### 语句

### 结构体

### 模块和脚本