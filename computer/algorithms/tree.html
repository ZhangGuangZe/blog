<!DOCTYPE html>
<html lang="en-US">
  <head>
    <meta charset="utf-8">
    <meta name="viewport" content="width=device-width,initial-scale=1">
    <title>树 | 前端男孩</title>
    <meta name="generator" content="VuePress 1.9.5">
    <link rel="icon" href="/blog/favicon.ico">
    <meta name="description" content="让学习前端变得更简单">
    
    <link rel="preload" href="/blog/assets/css/0.styles.e00172dc.css" as="style"><link rel="preload" href="/blog/assets/js/app.a1d041da.js" as="script"><link rel="preload" href="/blog/assets/js/3.157d387a.js" as="script"><link rel="preload" href="/blog/assets/js/29.b6ee7ea6.js" as="script"><link rel="prefetch" href="/blog/assets/js/10.10d04eac.js"><link rel="prefetch" href="/blog/assets/js/11.9ba3bd4a.js"><link rel="prefetch" href="/blog/assets/js/12.976294f0.js"><link rel="prefetch" href="/blog/assets/js/13.6d8c16d0.js"><link rel="prefetch" href="/blog/assets/js/14.de7902db.js"><link rel="prefetch" href="/blog/assets/js/15.5a1ba4fb.js"><link rel="prefetch" href="/blog/assets/js/16.5c0738b0.js"><link rel="prefetch" href="/blog/assets/js/17.24ad9fc5.js"><link rel="prefetch" href="/blog/assets/js/18.97466a80.js"><link rel="prefetch" href="/blog/assets/js/19.ab7f45bf.js"><link rel="prefetch" href="/blog/assets/js/20.bc814125.js"><link rel="prefetch" href="/blog/assets/js/21.d2e7a98e.js"><link rel="prefetch" href="/blog/assets/js/22.3972cd73.js"><link rel="prefetch" href="/blog/assets/js/23.051f60ea.js"><link rel="prefetch" href="/blog/assets/js/24.17690bc6.js"><link rel="prefetch" href="/blog/assets/js/25.fb9095e4.js"><link rel="prefetch" href="/blog/assets/js/26.d21ad9c7.js"><link rel="prefetch" href="/blog/assets/js/27.2e0727d0.js"><link rel="prefetch" href="/blog/assets/js/28.0d67e588.js"><link rel="prefetch" href="/blog/assets/js/30.633a0933.js"><link rel="prefetch" href="/blog/assets/js/31.039c8a8a.js"><link rel="prefetch" href="/blog/assets/js/32.ebd6d0af.js"><link rel="prefetch" href="/blog/assets/js/33.62d809ef.js"><link rel="prefetch" href="/blog/assets/js/34.748847d5.js"><link rel="prefetch" href="/blog/assets/js/35.7d036cca.js"><link rel="prefetch" href="/blog/assets/js/36.c916c0c5.js"><link rel="prefetch" href="/blog/assets/js/37.1874ee1e.js"><link rel="prefetch" href="/blog/assets/js/38.d2ec8309.js"><link rel="prefetch" href="/blog/assets/js/39.8dde5718.js"><link rel="prefetch" href="/blog/assets/js/4.7d540803.js"><link rel="prefetch" href="/blog/assets/js/40.c7c9be08.js"><link rel="prefetch" href="/blog/assets/js/41.87da1fc9.js"><link rel="prefetch" href="/blog/assets/js/42.b2733684.js"><link rel="prefetch" href="/blog/assets/js/43.9e0ee656.js"><link rel="prefetch" href="/blog/assets/js/44.63e7c722.js"><link rel="prefetch" href="/blog/assets/js/45.175455ba.js"><link rel="prefetch" href="/blog/assets/js/5.0e2a38a9.js"><link rel="prefetch" href="/blog/assets/js/6.e032fae7.js"><link rel="prefetch" href="/blog/assets/js/7.3f3e7035.js"><link rel="prefetch" href="/blog/assets/js/8.dab26245.js"><link rel="prefetch" href="/blog/assets/js/9.50c616e9.js"><link rel="prefetch" href="/blog/assets/js/vendors~docsearch.2dc030f4.js">
    <link rel="stylesheet" href="/blog/assets/css/0.styles.e00172dc.css">
  </head>
  <body>
    <div id="app" data-server-rendered="true"><div class="theme-container"><header class="navbar"><div class="sidebar-button"><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" role="img" viewBox="0 0 448 512" class="icon"><path fill="currentColor" d="M436 124H12c-6.627 0-12-5.373-12-12V80c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12zm0 160H12c-6.627 0-12-5.373-12-12v-32c0-6.627 5.373-12 12-12h424c6.627 0 12 5.373 12 12v32c0 6.627-5.373 12-12 12z"></path></svg></div> <a href="/blog/" class="home-link router-link-active"><!----> <span class="site-name">前端男孩</span></a> <div class="links"><form id="search-form" role="search" class="algolia-search-wrapper search-box"><input id="algolia-search-input" class="search-query"></form> <nav class="nav-links can-hide"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/guide/" class="nav-link">
  指南
</a></div><div class="nav-item"><a href="/blog/computer/" class="nav-link router-link-active">
  计算机基础
</a></div><div class="nav-item"><a href="/blog/front/" class="nav-link">
  前端知识体系
</a></div><div class="nav-item"><a href="https://github.com/ZhangGuangZe" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav></div></header> <div class="sidebar-mask"></div> <aside class="sidebar"><nav class="nav-links"><div class="nav-item"><a href="/blog/" class="nav-link">
  首页
</a></div><div class="nav-item"><a href="/blog/guide/" class="nav-link">
  指南
</a></div><div class="nav-item"><a href="/blog/computer/" class="nav-link router-link-active">
  计算机基础
</a></div><div class="nav-item"><a href="/blog/front/" class="nav-link">
  前端知识体系
</a></div><div class="nav-item"><a href="https://github.com/ZhangGuangZe" target="_blank" rel="noopener noreferrer" class="nav-link external">
  GitHub
  <span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></div> <!----></nav>  <ul class="sidebar-links"><li><section class="sidebar-group depth-0"><p class="sidebar-heading open"><span>数据结构与算法</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/computer/algorithms/" aria-current="page" class="sidebar-link">简介</a></li><li><a href="/blog/computer/algorithms/analysis.html" class="sidebar-link">算法分析</a></li><li><a href="/blog/computer/algorithms/array.html" class="sidebar-link">数组</a></li><li><a href="/blog/computer/algorithms/linked-list.html" class="sidebar-link">链表</a></li><li><a href="/blog/computer/algorithms/stack.html" class="sidebar-link">栈</a></li><li><a href="/blog/computer/algorithms/queue.html" class="sidebar-link">队列</a></li><li><a href="/blog/computer/algorithms/recursion.html" class="sidebar-link">递归</a></li><li><a href="/blog/computer/algorithms/sorting.html" class="sidebar-link">排序算法</a></li><li><a href="/blog/computer/algorithms/binary-search.html" class="sidebar-link">二分查找</a></li><li><a href="/blog/computer/algorithms/hash-table.html" class="sidebar-link">散列表</a></li><li><a href="/blog/computer/algorithms/tree.html" aria-current="page" class="active sidebar-link">树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/computer/algorithms/tree.html#二叉树" class="sidebar-link">二叉树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/computer/algorithms/tree.html#二叉树的类型" class="sidebar-link">二叉树的类型</a></li><li class="sidebar-sub-header"><a href="/blog/computer/algorithms/tree.html#二叉树的表示" class="sidebar-link">二叉树的表示</a></li><li class="sidebar-sub-header"><a href="/blog/computer/algorithms/tree.html#二叉树的遍历" class="sidebar-link">二叉树的遍历</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/computer/algorithms/tree.html#二叉搜索树" class="sidebar-link">二叉搜索树</a><ul class="sidebar-sub-headers"><li class="sidebar-sub-header"><a href="/blog/computer/algorithms/tree.html#查找操作" class="sidebar-link">查找操作</a></li><li class="sidebar-sub-header"><a href="/blog/computer/algorithms/tree.html#插入操作" class="sidebar-link">插入操作</a></li><li class="sidebar-sub-header"><a href="/blog/computer/algorithms/tree.html#删除操作" class="sidebar-link">删除操作</a></li><li class="sidebar-sub-header"><a href="/blog/computer/algorithms/tree.html#性能分析" class="sidebar-link">性能分析</a></li></ul></li><li class="sidebar-sub-header"><a href="/blog/computer/algorithms/tree.html#参考" class="sidebar-link">参考</a></li></ul></li><li><a href="/blog/computer/algorithms/heap.html" class="sidebar-link">堆</a></li><li><a href="/blog/computer/algorithms/trie.html" class="sidebar-link">Trie 树</a></li><li><a href="/blog/computer/algorithms/design.html" class="sidebar-link">算法设计</a></li><li><a href="/blog/computer/algorithms/graph.html" class="sidebar-link">图</a></li><li><a href="/blog/computer/algorithms/disjoint-set.html" class="sidebar-link">并查集</a></li><li><a href="/blog/computer/algorithms/strings.html" class="sidebar-link">字符串匹配算法</a></li></ul></section></li><li><section class="sidebar-group depth-0"><p class="sidebar-heading"><span>网络协议</span> <!----></p> <ul class="sidebar-links sidebar-group-items"><li><a href="/blog/computer/protocols/" class="sidebar-link">简介</a></li><li><a href="/blog/computer/protocols/udp.html" class="sidebar-link">UPD 协议</a></li><li><a href="/blog/computer/protocols/tcp.html" class="sidebar-link">TCP 协议</a></li><li><a href="/blog/computer/protocols/http.html" class="sidebar-link">HTTP 协议</a></li><li><a href="/blog/computer/protocols/https.html" class="sidebar-link">HTTPS 协议</a></li><li><a href="/blog/computer/protocols/dns.html" class="sidebar-link">DNS 协议</a></li></ul></section></li></ul> </aside> <main class="page"> <div class="theme-default-content content__default"><h1 id="树"><a href="#树" class="header-anchor">#</a> 树</h1> <p><strong>树</strong>（Tree）是一种由一系列节点组成的具有<strong>层次关系</strong>的数据结构。</p> <p>在树中，除了<strong>根节点</strong>外，每个节点只有一个<strong>父节点</strong>，每一个节点都有零个或多个<strong>子节点</strong>，没有子节点的节点称为<strong>叶子节点</strong>，相邻节点称为<strong>兄弟节点</strong>，每个节点以及后代构成了一棵<strong>子树</strong>。</p> <p>节点的<strong>高度</strong>是从该节点向下到叶子节点的最大长度，树的高度就是根节点的高度。节点的<strong>深度</strong>是从该节点向上到根节点的祖先节点数量。节点的<strong>层数</strong>是该节点的深度加 1。</p> <h2 id="二叉树"><a href="#二叉树" class="header-anchor">#</a> 二叉树</h2> <p><strong>二叉树</strong>（Binary tree）是一种每个节点最多有两个子节点的树结构。这两个子节点分别是<strong>左子节点</strong>和<strong>右子节点</strong>。</p> <p><img src="https://upload.wikimedia.org/wikipedia/commons/thumb/5/5e/Binary_tree_v2.svg/226px-Binary_tree_v2.svg.png" alt="二叉树"></p> <h3 id="二叉树的类型"><a href="#二叉树的类型" class="header-anchor">#</a> 二叉树的类型</h3> <p>二叉树根据叶子节点的分布可以归纳出两种类型：<strong>完全二叉树</strong>和<strong>满二叉树</strong>。</p> <p>除最后一层外其它层都是满的，如果最后一层的所有叶子节点尽可能的靠左，则是一棵完全二叉树，如果最后一层的叶子节点都存在，则是一棵满二叉树。</p> <h3 id="二叉树的表示"><a href="#二叉树的表示" class="header-anchor">#</a> 二叉树的表示</h3> <p>二叉树可以通过基于指针（或引用）的链表和基于下标（或索引）的数组表示。</p> <p>使用链表表示二叉树时，其中每个节点就是一个对象，对象中包含节点的数据以及指向左右子节点的指针。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">TreeNode</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>data <span class="token operator">=</span> data<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>left <span class="token operator">=</span> left<span class="token punctuation">;</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>right <span class="token operator">=</span> right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><p>使用数组表示二叉树时，每个节点就是一个数组元素，节点之间的父子关系通过下标计算得到。一般来说，为了计算方便，下标为 1 的位置存储根节点；下标为 2i 的位置存储左子节点；下标为 2i + 1 的位置存储右子节点；以此类推，下标为 i / 2 的位置就是父节点。</p> <p>使用数组可以有效的表示完全二叉树，因为根据完全二叉树的性质，节点与节点之间是连续的，这样在充分利用数组随机访问特性的同时，又不会浪费太多空间（仅浪费了下标为 0 的数组存储空间）。</p> <h3 id="二叉树的遍历"><a href="#二叉树的遍历" class="header-anchor">#</a> 二叉树的遍历</h3> <p>二叉树的遍历包括前序遍历、中序遍历、后序遍历和层次遍历。这里的前序、中序和后序指的是根节点与左右子树的位置。</p> <h4 id="前序遍历-根-左-右"><a href="#前序遍历-根-左-右" class="header-anchor">#</a> 前序遍历（根-左-右）</h4> <p>前序遍历首先遍历根节点，然后遍历左子树的节点，最后遍历右子树的节点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">preorderTraversal</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">preorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="中序遍历-左-根-右"><a href="#中序遍历-左-根-右" class="header-anchor">#</a> 中序遍历（左-根-右）</h4> <p>中序遍历首先遍历左子树的节点，然后遍历根节点，最后遍历右子树的节点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">inorderTraversal</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">inorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="后序遍历-左-右-根"><a href="#后序遍历-左-右-根" class="header-anchor">#</a> 后序遍历（左-右-根）</h4> <p>后序遍历首先遍历左子树的节点，然后遍历右子树的节点，最后遍历根节点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">postorderTraversal</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
  <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token function">postorderTraversal</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  console<span class="token punctuation">.</span><span class="token function">log</span><span class="token punctuation">(</span>root<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="层次遍历"><a href="#层次遍历" class="header-anchor">#</a> 层次遍历</h4> <p>层次遍历从根节点开始逐层从左到右遍历所有节点。层次遍历基于广度优先搜索和深度优先搜索算法实现。</p> <h5 id="基于广度优先搜索算法实现的层次遍历"><a href="#基于广度优先搜索算法实现的层次遍历" class="header-anchor">#</a> 基于广度优先搜索算法实现的层次遍历</h5> <p>以队列辅助结构，首先将根节点入队，然后出队当前节点的并将节点值存储在当前层的数组中，最后依次将当前节点的左右子节点加入到队列中，直到下一层没有节点为止。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">levelorderTraversal</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> queue <span class="token operator">=</span> <span class="token punctuation">[</span>root<span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>queue<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> level <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    <span class="token keyword">const</span> size <span class="token operator">=</span> queue<span class="token punctuation">.</span>length<span class="token punctuation">;</span>
    <span class="token keyword">for</span> <span class="token punctuation">(</span><span class="token keyword">let</span> i <span class="token operator">=</span> <span class="token number">0</span><span class="token punctuation">;</span> i <span class="token operator">&lt;</span> size<span class="token punctuation">;</span> i<span class="token operator">++</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">const</span> node <span class="token operator">=</span> queue<span class="token punctuation">.</span><span class="token function">shift</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
      level<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> queue<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>level<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="基于深度优先搜索-递归-算法实现的层次遍历"><a href="#基于深度优先搜索-递归-算法实现的层次遍历" class="header-anchor">#</a> 基于深度优先搜索（递归）算法实现的层次遍历</h5> <p>通过递归依次将当前深度的节点的值放入到当前层级数组中，并将当前层级信息传给下一次递归，直到递归完所有节点为止。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">levelorderTraversal</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> <span class="token function-variable function">helper</span> <span class="token operator">=</span> <span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> level</span><span class="token punctuation">)</span> <span class="token operator">=&gt;</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>level <span class="token operator">&gt;=</span> res<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      res<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
    res<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">helper</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token function">helper</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token function">helper</span><span class="token punctuation">(</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h5 id="基于深度优先搜索-迭代-算法实现的层次遍历"><a href="#基于深度优先搜索-迭代-算法实现的层次遍历" class="header-anchor">#</a> 基于深度优先搜索（迭代）算法实现的层次遍历</h5> <p>以栈作为辅助结构，首先将根节点和根节点的层级信息入栈，然后出栈当前节点和当前节点的层级信息，并将当前节点的值存储到当前层的数组中，最后从右到左将节点放入栈中，直到遍历完所有节点为止。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">function</span> <span class="token function">levelorderTraversal</span><span class="token punctuation">(</span><span class="token parameter">root</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>root<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>

  <span class="token keyword">const</span> res <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">const</span> stack <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">[</span>root<span class="token punctuation">,</span> <span class="token number">0</span><span class="token punctuation">]</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>stack<span class="token punctuation">.</span>length<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">const</span> <span class="token punctuation">[</span>node<span class="token punctuation">,</span> level<span class="token punctuation">]</span> <span class="token operator">=</span> stack<span class="token punctuation">.</span><span class="token function">pop</span><span class="token punctuation">(</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>level <span class="token operator">&gt;=</span> res<span class="token punctuation">.</span>length<span class="token punctuation">)</span> res<span class="token punctuation">[</span>level<span class="token punctuation">]</span> <span class="token operator">=</span> <span class="token punctuation">[</span><span class="token punctuation">]</span><span class="token punctuation">;</span>
    res<span class="token punctuation">[</span>level<span class="token punctuation">]</span><span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>val<span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> stack<span class="token punctuation">.</span><span class="token function">push</span><span class="token punctuation">(</span><span class="token punctuation">[</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> level <span class="token operator">+</span> <span class="token number">1</span><span class="token punctuation">]</span><span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> res<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>以上二叉树遍历的代码时间和空间复杂度都为 O(n)。</p> <h2 id="二叉搜索树"><a href="#二叉搜索树" class="header-anchor">#</a> 二叉搜索树</h2> <p><strong>二叉搜索树</strong>（Binary search tree，简称 BST），也称<strong>二叉查找树</strong>或者<strong>有序二叉树</strong>。二叉搜索树每个节点的值都大于<strong>左子树</strong>任意节点的值，且小于<strong>右子树</strong>任意节点的值。根据二叉搜索树<strong>有序性</strong>的特点，我们可以根据中序遍历，有序的输出所有节点。</p> <p><img src="https://upload.wikimedia.org/wikipedia/commons/1/10/Bstreesample.jpg" alt="二叉搜索树"></p> <p>二叉搜索树的结构，由一个值为 <code>null</code> 的根节点构成。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">class</span> <span class="token class-name">BinarySearchTree</span> <span class="token punctuation">{</span>
  <span class="token function">constructor</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="查找操作"><a href="#查找操作" class="header-anchor">#</a> 查找操作</h3> <h4 id="指定值"><a href="#指定值" class="header-anchor">#</a> 指定值</h4> <p>在二叉搜索树中查找指定值的节点。如果指定值的节点存在，返回该节点；否则如果不存在，返回 <code>null</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">search</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">searchNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 基于递归</span>
<span class="token function">searchNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node <span class="token operator">||</span> data <span class="token operator">===</span> node<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token keyword">return</span> node<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">searchNode</span><span class="token punctuation">(</span>data <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>data <span class="token operator">?</span> node<span class="token punctuation">.</span>left <span class="token operator">:</span> node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 基于迭代</span>
<span class="token function">searchNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>node<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">===</span> node<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token keyword">return</span> node<span class="token punctuation">;</span>
    node <span class="token operator">=</span> data <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>data <span class="token operator">?</span> node<span class="token punctuation">.</span>left <span class="token operator">:</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>我们首先从根节点开始查找，如果树为空，查找的值不存在，则返回 <code>null</code>；如果查找的值等于根节点的值，则返回该节点；如果查找的值小于根节点的值，则继续在左子树查找；如果查找的值大于根节点的值，则继续在右子树查找。重复这个过程，直到找到指定值的节点或者当前子树为空（也就是该值不存在）为止。</p> <h4 id="最小和最大节点"><a href="#最小和最大节点" class="header-anchor">#</a> 最小和最大节点</h4> <p>我们从根节点开始沿着左子节点查找直到当前节点的左子节点为空为止，即可得到最小节点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">min</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">minNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 基于递归</span>
<span class="token function">minNode</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">return</span> node<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">minNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 基于迭代</span>
<span class="token function">minNode</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    node <span class="token operator">=</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果根节点为空，则返回 <code>null</code>；如果根节点的左子节点为空，最小节点就是根节点；如果根节点的左子节点不为空，则最小节点在左子树中，需要继续向左查找。</p> <p>我们从根节点开始沿着右子节点查找直到当前节点的右子节点为空为止，即可得到最大节点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">max</span><span class="token punctuation">(</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">maxNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 基于递归</span>
<span class="token function">maxNode</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> node<span class="token punctuation">;</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">maxNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 基于迭代</span>
<span class="token function">maxNode</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>node <span class="token operator">&amp;&amp;</span> node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    node <span class="token operator">=</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h4 id="后继和前驱节点"><a href="#后继和前驱节点" class="header-anchor">#</a> 后继和前驱节点</h4> <p>有时候我们需要按中序遍历的次序查找指定节点的后继节点。后继节点是<strong>大于指定节点的最小节点</strong>。如果指定节点的后继节点存在，则返回它的后继节点；如果指定节点是树的最大节点，则返回 <code>null</code>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">successor</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">successor</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">successorNode</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">minNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> successor <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>data <span class="token operator">&gt;</span> node<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      successor <span class="token operator">=</span> root<span class="token punctuation">;</span>
      root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> successor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>查找指定节点后继节点的过程主要包括两种情况。如果指定节点的右子树非空，那么它的后继节点是右子树中的最小节点；如果指定节点的右子树为空，那么它的后继节点是拥有左子节点且是指定节点祖先节点的父节点。</p> <p>前驱节点与后继节点正好相反，是<strong>小于指定节点的最大节点</strong>。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">predecessor</span><span class="token punctuation">(</span><span class="token parameter">node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">predecessorNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> node<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">predecessorNode</span><span class="token punctuation">(</span><span class="token parameter">root<span class="token punctuation">,</span> node</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">maxNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> predecessor <span class="token operator">=</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>root<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>root<span class="token punctuation">.</span>data <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      predecessor <span class="token operator">=</span> root<span class="token punctuation">;</span>
      root <span class="token operator">=</span> root<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      root <span class="token operator">=</span> root<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> predecessor<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="插入操作"><a href="#插入操作" class="header-anchor">#</a> 插入操作</h3> <p>二叉搜索树的插入操作需要从根节点开始向下比较节点并根据结果向左或向右移动节点，直到当前节点移动方向的节点为 <code>null</code> 为止，最后在该方向插入节点。</p> <div class="language-js extra-class"><pre class="language-js"><code><span class="token function">insert</span><span class="token punctuation">(</span><span class="token parameter">data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 基于递归</span>
<span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>data<span class="token punctuation">)</span> node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">else</span> node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">insertNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token comment">// 基于迭代</span>
<span class="token function">insertNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token keyword">let</span> curr <span class="token operator">=</span> node<span class="token punctuation">;</span>
  <span class="token keyword">while</span> <span class="token punctuation">(</span>curr<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> curr<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>curr<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        curr<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
      <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>curr<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token punctuation">{</span>
        curr<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">new</span> <span class="token class-name">TreeNode</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
        <span class="token keyword">break</span><span class="token punctuation">;</span>
      <span class="token punctuation">}</span>
      curr <span class="token operator">=</span> curr<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token punctuation">}</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><p>如果树为空，我们将插入节点作为树的根节点；如果插入节点的数据比当前节点的数据小，并且当前节点没有左子节点，那就直接将新节点作为它的左子节点，如果有左子节点则继续在左子树中比较；如果插入节点的数据比当前节点的数据大，并且当前节点没有右子节点，那么就直接将新节点作为作为它的右子节点，如果有右子节点则继续在右子树中比较。</p> <h3 id="删除操作"><a href="#删除操作" class="header-anchor">#</a> 删除操作</h3> <p>二叉搜索树的删除节点操作首先从根节点向下查找删除节点，如果没有找到返回 <code>null</code>，如果找到删除节点后需要考虑三种情况。</p> <ul><li><p>删除的节点没有子节点，也就是删除的是一个叶子节点。我们直接将该节点置为 <code>null</code> 即可；</p></li> <li><p>删除的节点有一个子节点。我们需要用删除节点的子节点替换删除节点；</p></li> <li><p>删除的节点有两个子节点。我们需要用删除节点的后继节点，也就是删除节点右子树中最小节点替换删除的节点，然后删除后继节点。</p></li></ul> <div class="language-js extra-class"><pre class="language-js"><code><span class="token keyword">delete</span><span class="token punctuation">(</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">this</span><span class="token punctuation">.</span>root <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deleteNode</span><span class="token punctuation">(</span><span class="token keyword">this</span><span class="token punctuation">.</span>root<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
<span class="token punctuation">}</span>
<span class="token function">deleteNode</span><span class="token punctuation">(</span><span class="token parameter">node<span class="token punctuation">,</span> data</span><span class="token punctuation">)</span> <span class="token punctuation">{</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">)</span> <span class="token keyword">return</span> <span class="token keyword">null</span><span class="token punctuation">;</span>
  <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&lt;</span> node<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    node<span class="token punctuation">.</span>left <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deleteNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>left<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token keyword">if</span> <span class="token punctuation">(</span>data <span class="token operator">&gt;</span> node<span class="token punctuation">.</span>data<span class="token punctuation">)</span> <span class="token punctuation">{</span>
    node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deleteNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span> <span class="token keyword">else</span> <span class="token punctuation">{</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span>left<span class="token punctuation">)</span> <span class="token keyword">return</span> node<span class="token punctuation">.</span>right<span class="token punctuation">;</span>
    <span class="token keyword">if</span> <span class="token punctuation">(</span><span class="token operator">!</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span> <span class="token keyword">return</span> node<span class="token punctuation">.</span>left<span class="token punctuation">;</span>
    <span class="token keyword">const</span> minNode <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">minNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">)</span><span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>data <span class="token operator">=</span> minNode<span class="token punctuation">.</span>data<span class="token punctuation">;</span>
    node<span class="token punctuation">.</span>right <span class="token operator">=</span> <span class="token keyword">this</span><span class="token punctuation">.</span><span class="token function">deleteNode</span><span class="token punctuation">(</span>node<span class="token punctuation">.</span>right<span class="token punctuation">,</span> minNode<span class="token punctuation">.</span>data<span class="token punctuation">)</span><span class="token punctuation">;</span>
  <span class="token punctuation">}</span>
  <span class="token keyword">return</span> node<span class="token punctuation">;</span>
<span class="token punctuation">}</span>
</code></pre></div><h3 id="性能分析"><a href="#性能分析" class="header-anchor">#</a> 性能分析</h3> <p>二叉搜索树的性能与树的高度成正比。对于有 n 个节点的完全二叉树来说，以上二插搜索树操作的最坏情况时间复杂度为 O(logn)。然后，经过频繁操作后，树可能会退化为一条 n 个节点组成的链表，这些操作最坏情况时间复杂度为 O(n)。为了解决二叉搜索树在动态操作后造成的性能退化问题，可以使用红黑树等平衡二叉搜索树来保证这些操作在最坏情况下时间复杂度为 O(logn)。</p> <h2 id="参考"><a href="#参考" class="header-anchor">#</a> 参考</h2> <ul><li><a href="https://en.wikipedia.org/wiki/Tree_(data_structure)" target="_blank" rel="noopener noreferrer">Wikipedia<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li>《算法导论》</li> <li>《算法》（第4版）</li> <li>《数据结构与算法之美》</li> <li>《学习JavaScript数据结构与算法》（第3版）</li> <li><a href="https://space.bilibili.com/39312416/video" target="_blank" rel="noopener noreferrer">数据结构基础系列<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://time.geekbang.org/course/detail/100019701-42706" target="_blank" rel="noopener noreferrer">算法面试通关 40 讲<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li> <li><a href="https://leetcode.com/problemset/all/" target="_blank" rel="noopener noreferrer">Problems-LeetCode<span><svg xmlns="http://www.w3.org/2000/svg" aria-hidden="true" focusable="false" x="0px" y="0px" viewBox="0 0 100 100" width="15" height="15" class="icon outbound"><path fill="currentColor" d="M18.8,85.1h56l0,0c2.2,0,4-1.8,4-4v-32h-8v28h-48v-48h28v-8h-32l0,0c-2.2,0-4,1.8-4,4v56C14.8,83.3,16.6,85.1,18.8,85.1z"></path> <polygon fill="currentColor" points="45.7,48.7 51.3,54.3 77.2,28.5 77.2,37.2 85.2,37.2 85.2,14.9 62.8,14.9 62.8,22.9 71.5,22.9"></polygon></svg> <span class="sr-only">(opens new window)</span></span></a></li></ul></div> <footer class="page-edit"><!----> <div class="last-updated"><span class="prefix">更新时间:</span> <span class="time">8/24/2022, 10:07:48 PM</span></div></footer> <div class="page-nav"><p class="inner"><span class="prev">
      ←
      <a href="/blog/computer/algorithms/hash-table.html" class="prev">
        散列表
      </a></span> <span class="next"><a href="/blog/computer/algorithms/heap.html">
        堆
      </a>
      →
    </span></p></div> </main></div><div class="global-ui"></div></div>
    <script src="/blog/assets/js/app.a1d041da.js" defer></script><script src="/blog/assets/js/3.157d387a.js" defer></script><script src="/blog/assets/js/29.b6ee7ea6.js" defer></script>
  </body>
</html>
